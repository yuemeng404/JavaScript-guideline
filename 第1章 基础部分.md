> 本章节介绍JS与其他语言基本通用的内容，主要包括数据类型、表达式及语句等，只作简要描述。

# 一、词法

## 1、字面量

字面量（literal）是直接出现在程序的数值。

## 2、标识符

就是名字。

JavaScript的标识符必须以字母、下划线或美元符号开头。

## 3、保留字

包括关键字的所有不允许使用的标识符。某些关键字在某些环境下允许作为标识符使用，如可以用作对象的属性名，但尽量不这样用。

## 4、Unicode

JavaScript使用Unicode作为字符集，但考虑到可移植性等原因，标识符建议只使用ASCII字符。

# 二、数据类型

## 1、原始类型和对象类型

### （1）分类

JavaScript类型可以分为两类，`原始类型`和`对象类型`。普通对象可以看做是属性的集合。

对象类型是可修改的（mutation），原始类型是不可修改的（immutable）。

> 就这点而言，JS和python比较相似。

- **原始类型**
  - 数值型
  - 字符串型
  - 布尔型
  - Symbol型
  - null
  - undefined
- **对象类型**
  - array
  - Map
  - Set
  - RegExp
  - Date
  - Error
  - ....
  - **函数**
  - **类**

### （2）差别

可变与否只是分类数据类型的基本标准，在底层上它们有更显著的差异：

对于原始类型，只要它们字面量相同，它们就是相等的，即可以被`===`判真。

而对于对象类型，不同的对象永不相等（相同对象自然相等），也可以认为是因为对象没有字面量，就算两个对象的所有属性都相同，它们依然有些看不见的东西并不相同。

显然，对于对象的相等是如此严格，严格到这种相等已不再具备实际使用意义（完全可以用相同来描述这种关系），然而我们依旧有一种实际需求没有得到满足，那就是如何判断两个对象`看起来相等`呢（即具有相同的属性）？此时我们就需要枚举每一个属性进行比较来判断。值得注意的是当属性值是对象时我们还需要递归地去比较这个对象属性的子属性，确保每个`端属性`都被枚举到。

> 想要复制出一个看起来相等的数组对象可以使用`Array.from()`函数。



## 2、数值

### （1）字面量

```js
0
0xff	// 255
0b10101	// 21
0o377	// 255
3.14
.3333	// 0.333
6.02e-23
```

### （2）常用运算

- **Math类**
  - pow()
  - round()
  - random()
- Number类
  - parseInt()
  - parseFloat()
  - isNaN()

## 3、字符串

JavaScript使用Unicode字符集的UTF-16编码，以2个字节作为基本字单元，任何字符是基本字单元的整数倍（大部分为单个基本字单元大小）。字符串的length方法是基本字段元的长度。使用`for/of`循环或`...`操作符迭代字符串时以单个字符为单元。

### （1）常用方法

- substring()
- slice()
- split()
- indexOf()
- includes()
- replace()
- trim()

### （2）模板字符串

```js
let a = 1;
let b = 2;
let result = `sum of them is ${a+b}`;	// 3
```

> 大括号内容作为js表达式解释。

## 4、null 和 undefined

![img](img/v2-ae5b7d880c10946840c813b5257ce5a2_1440w.jpg)

用null表示程序级别、正常或意料之中的没有值；用undefined表示一种系统级别、意料之外或类似错误的没有值。

> 通常情况我会主动使用null而从不用undefined。

## 5、符号

符号类似于一种没有字面量的字符串，它最主要的特点是每次通过`Symbol(string)`生成的符号都是独一无二的。可以通过对`Symbol.for()`传入相同字符串时返回相同值的符号。

> 事实上每个对象类型也都是独一无二的，但符号是原始类型的，因为其不可变，且符号具有字符串的某些特性，可以作为对象的属性名。

## 6、全局对象

> 关于对象的内容在后续章节介绍，这里仅介绍全局对象。

全局对象是js工作的场景下的一个上帝对象，全局对象的属性是一系列全局定义的`常量`（undefined等）、`函数`（eval() 等）和`对象`（Math）。

因为全局对象的属性是全局定义的，所以可以像全局变量一样使用这些属性，而无需像`对象.属性`的形式来使用。全局对象也都有一个用来引用本身的属性，在浏览器环境中是`window`，在Node环境中是`global`，在想要操作全局对象本身时可以这些属性来代替。

> ES2020定义了`globalThis`属性以在任何环境下引用全局对象。

# 三、变量和常量

变量容易理解，何为常量？**把一个值永久地赋给一个名字，这个名字就是常量。**

常量是指名字和值映射关系的一种绑定，值的可变与否不守此约束，那是值所属的数据类型决定的。

## let

我们使用`let`声明变量，具有块级作用域，和其他高级语言的变量行为基本完全一致。

## const

使用`const`声明常量，常量在声明时必须初始化，也是块级作用域。

> 块级作用域指`{}`包含的代码块（包括在某些时候大括号本身省略时），显然函数作用域也属于块级作用域。

## var

在ES6之前，js只能会用var声明变量，var具有一些奇怪的特性，现在尽量废弃掉var，但了解这些特性是必要的。

- var只有函数作用域。一切函数体之外的var变量都是全局变量。
- 通过var声明的全局变量作为全局对象的属性存在，这点与const和let不同。该属性不能通过`delete`操作符删除。
- 在同一作用域下使用var多次声明同名变量是合法的。
- var声明的变量会被提升到作用域最前面（hoisting），故可以在声明之前引用var变量，此时引用的值为undefined（let下这种情况会报错），因为var变量的初始化还是在原来的位置。显然这个特性并不会有实际的价值，且常常引发错误。

> 在非严格模式下，可以给从未声明的变量赋值，此时会创建一个新的全局变量，而不论该赋值操作是否在全局作用域下。该全局变量亦是作为全局对象的属性存在，但可以被delete操作删除。

# 四、语句

> JavaScript是类c语言。语句上几乎完全继承了c的语法，暂且不再赘述。只讲述个别特性。

## 1、关于遍历

### for/of

`for/of`循环只能作用域`可迭代对象`，例如数组、字符串和集合等，注意对象（默认）不是可迭代对象。

```js
let m = new Map([["key", "value"]]);
for(let [k, v] of m){
    k	// "key"
    v	// "value"
}

```

本例用到了`Map()`和`解构赋值`，在后面会具体介绍。

> 数组的迭代是`实时`的，迭代时的操作会反馈到之后的迭代过程。

### for/in

`for/in`可以枚举任何对象，但只能枚举对象的`可枚举属性`（在对象章节有介绍），且会枚举继承的可枚举属性，这可能不是我们真正想要的，我们可能只想遍历自己显示添加上的那些属性，于是可以使用`Object`对象的一些方法结合`for/of`来达到想要的效果。

- **Object.keys()**

  返回对象`属性名`的数组，于是再使用`for/of`来遍历。

  ```js
  for(let k of o.keys()){
      o.k	...
  }
  ```

- **Object.values()**

  返回对象`属性值`的数组。

- **Object.entries()**

  返回键值对数组的数组，需要使用二元数组来解构赋值。

> 当枚举的的对象是数组时，遍历出的内容为数组的`索引值`，而不是内容，所以遍历数组时最好使用`for/of`。

## 2、关于严格模式

严格模式指在脚本或函数体的开头使用`"use strict"`指令，以对语句提供更强的错误检查，修复了部分语言缺陷。

严格模式的要求很多，但很多在基础开发不会涉及或者本身已经成为了一种默认的规范，在这里只介绍常见的几条规则。

- 不允许使用`with`语句。实际上with语句在非严格模式下也几乎废弃。
- 变量在使用前必须声明。之前提到给未声明的变量赋值是允许的，相当于全局变量，这在严格模式下是禁止的。
- 函数作为函数（而非方法）调用时，`this`的指向为`undefined`。关于this指向是后面的重点。
